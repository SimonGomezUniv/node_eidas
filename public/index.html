

<!doctype html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EIDAS Photo Demo</title>
    <link  rel="stylesheet"  href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <meta http-equiv="Content-Language" content="en">
    <script src="/json2list.js"></script>
    <link rel="icon" href="/logo.png" type="image/png">
</head>
<body>
    <div id="websocket-status-banner" style="display: none; background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; padding: 10px; text-align: center; position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; box-sizing: border-box;">
        <!-- Warning message will be inserted here by JavaScript -->
    </div>
    <main class="container">
        <h1>EIDAS Photo Demo</h1>
        <p>Scan the QR code with your wallet to get the photo.</p>
        <p>Click the button to launch the wallet.</p>
    
        <select id="options">
            <option value="photo">Photo</option>
            <option value="name">Name</option>
            <option value="mail">Mail</option>
        </select>
        <!-- Removed autofetch checkbox and its fieldset -->
        <div id="debug" style="display: none;">
            <h2>Debug</h2>
            <input  id="input" id="input" placeholder="Type something..." />
            
            <button onclick="generateQrcode()">generate qrcode </button>
            <button onclick="resetPhoto()">reset Photo</button>
            <button onclick="updateAppLink()">Update Link</button>
            
        </div>
        <br />
        <button class="secondary" onclick="debug()">Debug</button>
        <br />
        <br />
        <button id="wallet">launch Wallet </button>
        <div id="qr-code"></div>
        <div id="photo"></div>

        <hr> <!-- Adding a horizontal rule for separation -->

        <!-- Old loadDataButton and display areas removed -->

        <div id="vc-presentation-results" style="margin-top: 20px;">
            <div id="formatted-vc-display" style="border: 1px solid #ade; padding: 10px; margin-bottom: 10px;">
                <h3>Verifiable Credential Data</h3>
                <p><em>Waiting for data via WebSocket...</em></p>
            </div>
            <div id="technical-info-display" style="border: 1px solid #eda; padding: 10px;">
                <h3>Technical Analysis & Logs</h3>
                <pre><em>Waiting for data via WebSocket...</em></pre>
            </div>
        </div>
    </main>
</body>

<script>

    var dns_rp="http://192.168.1.19:3000"
    var nounce="random_string"
function debug(){
    const debugDiv = document.getElementById('debug');
    if (debugDiv.style.display === 'none') {
        debugDiv.style.display = 'block';
    } else {
        debugDiv.style.display = 'none';
    }
}

    function resetPhoto() {
        fetch('/reset-photo')
            .then(response => response.text())
            .then(html => {
                const photoDiv = document.getElementById('photo');
                photoDiv.innerHTML = html;
            })
            .catch(error => {
                console.error('Error resetting photo:', error);
            });
    }


    function updateAppLink(){
        qr_code_redirect = document.getElementById("input").value;
        document.getElementById("wallet").onclick = function() {
                window.open(qr_code_redirect, '_blank');
            };
    }

    function generateCodeFromRp(){

        fetch('/dns_rp')
        .then(response => response.json())
        .then(data => {
            dns_rp = data.dns_rp;
            nounce=document.getElementById("options").value+Math.floor(100000 + Math.random() * 900000)
            qr_code_redirect = `openid4vp://?client_id=my_client_id&request_uri=${dns_rp}/request-object/${nounce}`;
            document.getElementById("wallet").onclick = function() {
                window.open(qr_code_redirect, '_blank');
            };
            document.getElementById("input").value = qr_code_redirect;
            generateQrcode();
        })
        .catch(error => {
            console.error('Error fetching dns_rp:', error);
        });
    }
    
    generateCodeFromRp();
    document.getElementById("options").addEventListener("change", function() {
        nounce=document.getElementById("options").value+Math.floor(100000 + Math.random() * 900000)
        qr_code_redirect = `openid4vp://?client_id=my_client_id&request_uri=${dns_rp}/request-object/${nounce}`;
        document.getElementById("input").value = qr_code_redirect;
        generateQrcode();
    });

    function generateQrcode() {
        const inputValue = document.getElementById("input").value;
        fetch('/generate-qrcode', {
            method: 'POST',
            headers: {
            'Content-Type': 'application/json'
            },
            body: JSON.stringify({ text: inputValue })
        })
        .then(response => response.json())
        .then(data => {
            console.log('QR Code generated:', data);
            
            document.getElementById('qr-code').innerHTML = `<img src="${data.qrCode}" alt="QR Code" />`;
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }


    // Old fetchPhoto, loadData, and toggleFetchingPhoto functions are removed as they are obsolete.

    document.addEventListener('DOMContentLoaded', () => {
        const formattedVcArea = document.getElementById('formatted-vc-display');
        // technicalInfoPre is no longer the primary container for structured debug data.
        // We will use technicalInfoDisplayDiv and clear/repopulate it.
        const technicalInfoDisplayDiv = document.getElementById('technical-info-display');
        
        // Determine WebSocket protocol and host
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}`;
        const socket = new WebSocket(wsUrl);

        function displayVcUpdate(payload) {
            console.log("Displaying VC_DATA_UPDATE:", payload);

            const claimKeyMappings = {
                'iss': 'Issuer (iss)',
                'sub': 'Subject (sub)',
                'aud': 'Audience (aud)',
                'exp': 'Expiration Time (exp)',
                'nbf': 'Not Before (nbf)',
                'iat': 'Issued At (iat)',
                'jti': 'JWT ID (jti)',
                'given_name': 'Given Name',
                'family_name': 'Family Name',
                'email': 'Email Address',
                'birthdate': 'Birth Date',
                // Add other known SD-JWT or JWT claim keys that need friendlier names
            };

            // Populate #formatted-vc-display
            formattedVcArea.innerHTML = '<h3>Verifiable Credential Data</h3>'; // Reset heading
            if (payload.formattedVcData && payload.formattedVcData.claims) {
                if (payload.formattedVcData.claims.length === 0) {
                    formattedVcArea.innerHTML += '<p><em>No claims found in the credential.</em></p>';
                }
                payload.formattedVcData.claims.forEach(claim => {
                    const originalLabel = claim.label || (claim.type === 'image' ? 'Image' : 'Claim');
                    // Ensure lookup is case-insensitive by converting originalLabel to lowercase
                    const displayLabel = claimKeyMappings[originalLabel.toLowerCase()] || originalLabel;

                    if (claim.type === 'image' && claim.value) {
                        // Display the label for the image
                        const imgLabel = document.createElement('p');
                        imgLabel.innerHTML = `<strong>${escapeHtml(displayLabel)}:</strong>`; // Using innerHTML for strong tag
                        formattedVcArea.appendChild(imgLabel);

                        const imgElement = document.createElement('img');
                        imgElement.src = claim.value;
                        imgElement.alt = escapeHtml(displayLabel); // Use escaped displayLabel for alt text
                        imgElement.style.maxWidth = '200px'; // Or some other appropriate size
                        imgElement.style.height = 'auto';
                        imgElement.style.display = 'block';
                        imgElement.style.marginTop = '5px'; // As per example
                        imgElement.style.marginBottom = '10px'; // As per example
                        formattedVcArea.appendChild(imgElement);
                    } else if (claim.type === 'text' && claim.value !== undefined) {
                        const p = document.createElement('p');
                        p.innerHTML = `<strong>${escapeHtml(displayLabel)}:</strong> ${escapeHtml(String(claim.value))}`;
                        formattedVcArea.appendChild(p);
                    } else {
                        console.warn("Skipping claim due to missing value or unknown type:", claim);
                    }
                });
            } else {
                formattedVcArea.innerHTML += '<p><em>No formatted claims data received.</em></p>';
            }
             // Add overall status to formattedVcArea
            const statusP = document.createElement('p');
            let statusText = escapeHtml(payload.status || 'N/A');
            let statusEmoji = '';
            if (statusText.toLowerCase().includes('verified')) {
                statusEmoji = '✅ ';
            } else if (statusText.toLowerCase().includes('failed') || statusText.toLowerCase().includes('error')) {
                statusEmoji = '❌ ';
            }
            statusP.innerHTML = `<strong>Overall Status:</strong> ${statusEmoji}${statusText}`;
            formattedVcArea.appendChild(statusP);

            // --- Populate #technical-info-display with structured tables ---
            technicalInfoDisplayDiv.innerHTML = '<h3>Technical Analysis & Logs</h3>'; // Clear and set main heading

            if (payload.technicalDebugData && Object.keys(payload.technicalDebugData).length > 0) {
                const techData = payload.technicalDebugData;

                // 1. Certificate Information Table
                const certHeading = document.createElement('h4');
                certHeading.textContent = 'Certificate Information';
                technicalInfoDisplayDiv.appendChild(certHeading);
                const certificateData = techData.certificate; // Changed key
                if (certificateData) {
                    const certDataRows = [
                        ['Subject', escapeHtml(certificateData.subject || 'N/A')],
                        ['Issuer', escapeHtml(certificateData.issuer || 'N/A')],
                        ['Validity', `Not Before: ${escapeHtml(certificateData.validity?.notBefore || 'N/A')}, Not After: ${escapeHtml(certificateData.validity?.notAfter || 'N/A')}`]
                    ];
                    technicalInfoDisplayDiv.appendChild(
                        createTableForTechInfo(['Attribute', 'Value'], certDataRows, 'Certificate data not available.', escapeHtml)
                    );
                } else {
                    const noCertInfoP = document.createElement('p');
                    noCertInfoP.innerHTML = '<em>Certificate information not available.</em>';
                    technicalInfoDisplayDiv.appendChild(noCertInfoP);
                }

                // 2. JWT/SD-JWT Validation Steps Table
                const valStepsHeading = document.createElement('h4');
                valStepsHeading.textContent = 'JWT/SD-JWT Validation Steps'; // Updated heading for clarity
                technicalInfoDisplayDiv.appendChild(valStepsHeading);
                const jwtValidationStepsData = techData.jwtValidationSteps; // Changed key
                let valStepsRows = [];
                if (jwtValidationStepsData && jwtValidationStepsData.length > 0) {
                    valStepsRows = jwtValidationStepsData.map(step => [
                        escapeHtml(step.step || 'N/A'),
                        escapeHtml(step.status || 'N/A'),
                        // Assuming step.details could be an object, stringify for basic display
                        escapeHtml(step.details ? (typeof step.details === 'object' ? JSON.stringify(step.details) : step.details) : 'N/A')
                    ]);
                }
                technicalInfoDisplayDiv.appendChild(
                    createTableForTechInfo(['Step', 'Status', 'Details'], valStepsRows, 'No validation steps recorded.', escapeHtml)
                );
                
                // 3. Server Logs/Analyses Table
                const logsHeading = document.createElement('h4');
                logsHeading.textContent = 'Server Logs/Analyses'; // Updated heading for clarity
                technicalInfoDisplayDiv.appendChild(logsHeading);
                const serverAnalysisData = techData.serverAnalysis; // Changed key
                let serverAnalysisRows = [];
                if (serverAnalysisData && serverAnalysisData.length > 0) {
                    serverAnalysisRows = serverAnalysisData.map(log => [
                        escapeHtml(log.timestamp || 'N/A'),
                        escapeHtml(log.message || 'N/A') 
                        // 'level' is omitted as per instruction that it might be missing
                    ]);
                }
                technicalInfoDisplayDiv.appendChild(
                    // Headers changed to reflect omission of 'level'
                    createTableForTechInfo(['Timestamp', 'Message'], serverAnalysisRows, 'No server logs or analyses recorded.', escapeHtml)
                );

            } else {
                const noTechDataP = document.createElement('p');
                noTechDataP.innerHTML = '<em>Technical debug data not available or empty.</em>';
                technicalInfoDisplayDiv.appendChild(noTechDataP);
            }
        }

        function displayProcessingError(payload) {
            console.log("Displaying PROCESSING_ERROR:", payload);
            formattedVcArea.innerHTML = `<h3>Processing Error</h3>
                                         <p><strong>Error:</strong> ${escapeHtml(payload.error || 'Unknown error')}</p>
                                         <p><strong>Status:</strong> ${escapeHtml(payload.status || 'N/A')}</p>`;
            
            technicalInfoDisplayDiv.innerHTML = '<h3>Technical Analysis & Logs</h3>';
            const detailsP = document.createElement('p');
            detailsP.textContent = JSON.stringify(payload.details, null, 2); // Keep raw JSON for error details
            technicalInfoDisplayDiv.appendChild(detailsP);
        }

        function resetDisplayAreas(payload) {
            console.log("Displaying VC_DATA_RESET:", payload);
            const message = payload.message || "Waiting for data via WebSocket...";
            formattedVcArea.innerHTML = `<h3>Verifiable Credential Data</h3><p><em>${escapeHtml(message)}</em></p>`;
            
            technicalInfoDisplayDiv.innerHTML = '<h3>Technical Analysis & Logs</h3>';
            const messageP = document.createElement('p');
            messageP.innerHTML = `<em>${escapeHtml(message)}</em>`;
            technicalInfoDisplayDiv.appendChild(messageP);
        }

        function escapeHtml(unsafe) {
            if (unsafe === null || unsafe === undefined) return '';
            return String(unsafe)
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // Helper function to create a table for technical information
        function createTableForTechInfo(headersArray, dataRowsArray, emptyMessage, escapeFunction) {
            const table = document.createElement('table');
            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            headersArray.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = escapeFunction(headerText);
                headerRow.appendChild(th);
            });

            const tbody = table.createTBody();
            if (!dataRowsArray || dataRowsArray.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = headersArray.length;
                cell.innerHTML = `<em>${escapeFunction(emptyMessage)}</em>`; // Italicize empty message
            } else {
                dataRowsArray.forEach(rowData => {
                    const row = tbody.insertRow();
                    rowData.forEach(cellData => {
                        const cell = row.insertCell();
                        // Cell data is pre-escaped before being passed to this function for most cases,
                        // but applying here ensures safety if raw data were passed by mistake.
                        // For complex structures like the 'Validity' field, it's formatted and escaped before this point.
                        cell.innerHTML = cellData; // Use innerHTML as data might be pre-formatted (e.g. validity string)
                    });
                });
            }
            return table;
        }

        socket.onopen = () => {
            console.log('WebSocket connection established.');
            const banner = document.getElementById('websocket-status-banner');
            if (banner) {
                banner.style.display = 'none'; // Hide the warning banner
            }

            if (formattedVcArea) {
                formattedVcArea.innerHTML = '<h3>Verifiable Credential Data</h3><p><em>WebSocket connecté. En attente de données...</em></p>';
            }
            // Update technicalInfoDisplayDiv for initial state
            if (technicalInfoDisplayDiv) {
                technicalInfoDisplayDiv.innerHTML = '<h3>Technical Analysis & Logs</h3><p><em>WebSocket connecté. En attente de données...</em></p>';
            }
        };

        socket.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                // Enhanced log: Immediately after parsing
                console.log('[WS Client] Successfully parsed message. Type:', message.type, 'Payload keys:', Object.keys(message.payload || {}).join(', '));
                // console.log('WebSocket message received:', message); 

                if (message.type === 'VC_DATA_UPDATE') {
                    displayVcUpdate(message.payload);
                } else if (message.type === 'PROCESSING_ERROR') {
                    displayProcessingError(message.payload);
                } else if (message.type === 'VC_DATA_RESET') {
                    resetDisplayAreas(message.payload);
                } else {
                    console.warn('Unknown WebSocket message type:', message.type);
                    if (technicalInfoDisplayDiv) { // Check if div exists
                        technicalInfoDisplayDiv.innerHTML = `<h3>Technical Analysis & Logs</h3><p>Received unknown message type: ${escapeHtml(message.type)}</p>`;
                    }
                }
                // Enhanced log: At the end of the try block
                console.log('[WS Client] Finished processing message logic for type:', message.type);
            } catch (e) {
                console.error('Error processing WebSocket message:', e);
                technicalInfoPre.textContent = `Error processing message from server: ${e.message}`;
            }
        };

        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            formattedVcArea.innerHTML = '<h3>Verifiable Credential Data</h3><p><em>WebSocket connection error. See console for details.</em></p>';
            if (technicalInfoDisplayDiv) { // Check if div exists
                technicalInfoDisplayDiv.innerHTML = '<h3>Technical Analysis & Logs</h3><p><em>WebSocket connection error. See console for details.</em></p>';
            }
        };

        socket.onclose = (event) => { 
            console.log('WebSocket connection closed. Code:', event.code, 'Reason:', (event.reason || "No reason provided"));
            const banner = document.getElementById('websocket-status-banner');
            if (banner) {
                banner.innerHTML = "Connexion WebSocket interrompue (Code: " + (event.code || 'N/A') + 
                                   "). Les données affichées peuvent ne plus être à jour. " +
                                   "Actualisez la page pour tenter de vous reconnecter.";
                banner.style.display = 'block';
            }

            // DO NOT CLEAR the main content areas. The lines below were removed/commented out:
            // formattedVcArea.innerHTML = `<h3>Verifiable Credential Data</h3><p><em>WebSocket disconnected. Code: ${event.code}. Please refresh.</em></p>`;
            // technicalInfoPre.textContent = `WebSocket disconnected. Code: ${event.code}. Please refresh.`;
        };
    });

</script>

</html>